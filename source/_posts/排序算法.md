---
title: 排序算法
date: 2017-06-03 16:30:52
tags:
category: [python,排序算法]
---
随便写写排序算法的python实现,顺便熟悉一下所谓python风格,省的熊大再说我的代码一点都不python...
吐槽一下某人大半年前把自己定义的类的属性和属性类型改了几个,我这边好久没动mobile的代码,已更新发现各种报错...周末虚拟机关了也没法联调,略坑啊~
<!--more-->
## 插入排序

直接插入排序是一种简单的插入排序法，其基本思想是：把待排序的纪录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的纪录插入完为止，得到一个新的有序序列。

生成一个新数组,依次将原始数组中的元素插入新数组中,然后逐个比较元素与新数组中已有元素的大小,通过交换位置的方式确定排序,循环结束完成排序
时间复杂度：O（n^2）

```python
def insert_sort(li):
    r,t=[],0
    for l in li:
        r +=[l]
        a = len(r)
        for x in range(a):
            if r[x]>r[a-1]:
                # 这里写成一行会报错
                t = r[x]
                r[x] = r[a-1]
                r[a-1] = t
    return r
```

网上的写法

```python
def insert_sort(lists):
    # 插入排序
    count = len(lists)
    for i in range(1, count):
        key = lists[i]
        j = i - 1
        while j >= 0:
            if lists[j] > key:
                lists[j + 1] = lists[j]
                lists[j] = key
            j -= 1
    return lists
```

## 希尔排序

希尔排序是基于插入排序的以下两点性质而提出改进方法的：
插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。
但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。

先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2<d1重复上述的分组和排序，直至所取的增量  =1(  <  …<d2<d1)，即所有记录放在同一组中进行直接插入排序为止。
该方法实质上是一种分组插入方法
比较相隔较远距离（称为增量）的数，使得数移动时能跨过多个元素，则进行一次比[2]  较就可能消除多个元素交换。D.L.shell于1959年在以他名字命名的排序算法中实现了这一思想。算法先将要排序的一组数按某个增量d分成若干组，每组中记录的下标相差d.对每组中全部元素进行排序，然后再用一个较小的增量对它进行，在每组中再进行排序。当增量减到1时，整个要排序的数被分成一组，排序完成。
一般的初次取序列的一半为增量，以后每次减半，直到增量为1。


```python
def shell(arr):
    n=len(arr)
    h=1
    while h<n/3:
        h=3*h+1
    while h>=1:
        for i in range(h,n):
            j=i
            temp=arr[j]
            while j>=h and arr[j]<arr[j-h]:
                arr[j]=arr[j-h]
                arr[j-h]=temp
                j-=h
        h=round(h/3)
    return arr
```

```python
def shell_sort(lists):
    # 希尔排序
    count = len(lists)
    step = 2
    group = round(count / step)
    while group > 0:
        for i in range(0, group):
            j = i + group
            while j < count:
                k = j - group
                key = lists[j]
                while k >= 0:
                    if lists[k] > key:
                        lists[k + group] = lists[k]
                        lists[k] = key
                    k -= group
                j += group
        group = round(group/step)
    return lists
```

## 选择排序

### 普通选择排序

遍历数组,选择最大(或最小)的元素交换位置,然后从第二位开始继续遍历,直到最后完成排序

```python
def select_sort(li):
    i,a=0,len(li)
    for x in range(a):
        imin = li[x]
        for y in range(x,a):
            if imin>li[y]:
                imin,i= li[y],y
        if imin<li[x]:
            li[i] = li[x]
            li[x] = imin
    return li
```

### 二元选择排序

每次遍历同时确定最大和最小值,并交换位置,可以减少循环时间

```python

```

## 堆排序

```python
def heap_sort(lst):
for startinrange((len(lst)-2)/2,-1,-1):
sift_down(lst,start,len(lst)-1)
 
for endinrange(len(lst)-1,0,-1):
lst[0],lst[end]=lst[end],lst[0]
sift_down(lst,0,end-1)
return lst
 
def sift_down(lst,start,end):
root=start
while True:
child=2*root+1
if child>end:
break
if child+1<=end and lst[child]<lst[child+1]:
child+=1
if lst[root]<lst[child]:
lst[root],lst[child]=lst[child],lst[root]
root=child
else:
break
```

## 交换排序

### 冒泡

冒泡排序算法的运作如下：（从后往前）
比较相邻的元素。如果第一个比第二个大，就交换他们两个。
对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
针对所有的元素重复以上的步骤，除了最后一个。
持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。

```python
def bubble(li):
    l,t=len(li),0
    while l>0:
        for i in range(l-1):
            if li[i] > li[i+1]:
                t = li[i]
                li[i] = li[i+1]
                li[i+1]=t
        l-=1
    return li
```

网上的写法

```python
def bubble_sort(lists):
    # 冒泡排序
    count = len(lists)
    for i in range(0, count):
        for j in range(i + 1, count):
            if lists[i] > lists[j]:
                lists[i], lists[j] = lists[j], lists[i]
    return lists
def bubble_sort(lists):
    for i in range(0, len(lists) - 1):                 # 记录冒泡的次数
        for j in range(0, len(lists)-1-i):             # 记录每轮冒泡排序比较的次数
            if lists[j] > lists[j + 1]:
                lists[j + 1], lists[j] = lists[j], lists[j+ 1]
                j = j + 1
            else:
                continue
    return lists
def bubbleSort(L):
    length = len(L)
    if length==0 or length==1:
        return L
    for i in range(length):
        for j in range(length-1-i):
            if L[j] > L[j+1]: 
                temp = L[j]
                L[j] = L[j+1]
                L[j+1] = temp
    return L
```

### 冒泡改进1

增加标识,如果内部一次遍历没有发生数据交换,则可以判断数据已经有序,立即结束即可
性能提升一般

```python
def bubble1(li):
    l,t=len(li),0
    ex = 1
    while l>0:
        for i in range(l-1):
            if li[i] > li[i+1]:
                ex += 1
                t = li[i]
                li[i] = li[i+1]
                li[i+1]=t
        if ex<1:
            return li
        ex=0
        l-=1
    return li
```

### 冒泡改进2

设置变量记录上次一交换发生的位置,表示后面的元素都已经有序所以不需要交换,缩小遍历数据的范围
`删了...写了好久不知道为啥跑出来都不对,先把基本的写完慢慢改进吧`

```python
def bubble(li):
    r ,x ,f= 0,0,0
    for x in range(len(li)):
        f=0
        for i in range(len(li)):
            if li[x]<li[i]:
                f +=1
                r = li[x]
                li[x] =li[i]
                li[i]=r
        if f==0:
            return li
    return li
```

### 冒泡改进3

一次遍历过程中同时取出最大最小值交换至两端,可以减少一半的迭代

```python

```

## 快速排序

### 基本排序

随机(实际上不太好随机操作)取某一个元素作为基准,降大于元素的作为一个数组,小于的作为一个数组,递归切割,直到所有的子数组都只有一个元素的时候返回,即为有序数组

```python
def quick_sort(li):
    if len(li)==1:
        return li
    if len(li)==0:
        return []
    left,right,cursor=[],[],li[0]
    for l in li:
        if l>cursor:
            right.append(l)
        if l<cursor:
            left.append(l)
    if len(left)>1:
        left = quick_sort(left)
    if len(right)>1:
        right = quick_sort(right)
    return left+[cursor]+right
```

### 改进

只对长度大于k的子序列递归调用快速排序,让原序列基本有序，然后再对整个基本有序序列用插入排序算法排序。改进后的算法时间复杂度有所降低，且当k取值为 8 左右时,改进算法的性能最佳

```python

```